//  app.js 또는 server.js 상단에 다음 코드를 넣어 서버가 "로그인 상태"를 기억하게 만듭니다.

//    1 const session = require('express-session');
//    2
//    3 app.use(session({
//    4     secret: 'my_secret_key', // 아무 문자열이나 넣으세요
//    5     resave: false,
//    6     saveUninitialized: true
//    7 }));

//   ---

//   3. 로그인 기능 (평문 비교)
//   사용자가 입력한 ID와 PW를 DB와 대조합니다. DB의 USERS 테이블에는 USER_ID, PASSWORD, USER_ROLE 컬럼이 있다고 가정합니다.

//     1 app.post('/login', async (req, res) => {
//     2     const { id, password } = req.body;
//     3     let connection;
//     4
//     5     try {
//     6         connection = await oracledb.getConnection(dbConfig);
//     7
//     8         // ID와 PW가 모두 일치하는 행이 있는지 조회
//     9         const sql = `SELECT USER_ID, USER_NAME, USER_ROLE
//    10                      FROM USERS
//    11                      WHERE USER_ID = :id AND PASSWORD = :pw`;
//    12
//    13         const result = await connection.execute(sql, { id: id, pw: password }, {
//    14             outFormat: oracledb.OUT_FORMAT_OBJECT
//    15         });
//    16
//    17         if (result.rows.length > 0) {
//    18             // 로그인 성공: 세션에 사용자 정보 저장
//    19             const user = result.rows[0];
//    20             req.session.user = {
//    21                 id: user.USER_ID,
//    22                 name: user.USER_NAME,
//    23                 role: user.USER_ROLE // 'ADMIN' 또는 'USER' 등이 저장됨
//    24             };
//    25
//    26             res.send(`<script>alert('${user.USER_NAME}님 환영합니다!'); location.href='/';</script>`);
//    27         } else {
//    28             // 로그인 실패
//    29             res.send('<script>alert("아이디 또는 비밀번호가 틀렸습니다."); history.back();</script>');
//    30         }
//    31     } catch (err) {
//    32         console.error(err);
//    33         res.status(500).send("로그인 중 오류 발생");
//    34     } finally {
//    35         if (connection) await connection.close();
//    36     }
//    37 });

//   ---

//   4. 권한 체크 미들웨어 만들기
//   특정 페이지에 들어갈 때 "로그인을 했는지", "관리자인지" 확인하는 함수입니다.

//     1 // 로그인 했는지 확인하는 함수
//     2 function checkLogin(req, res, next) {
//     3     if (req.session.user) {
//     4         next(); // 로그인 되어있으면 다음 단계(페이지 접속)로 진행
//     5     } else {
//     6         res.send('<script>alert("로그인이 필요합니다."); location.href="/login";</script>');
//     7     }
//     8 }
//     9
//    10 // 관리자인지 확인하는 함수
//    11 function checkAdmin(req, res, next) {
//    12     if (req.session.user && req.session.user.role === 'ADMIN') {
//    13         next(); // 관리자면 통과
//    14     } else {
//    15         res.send('<script>alert("관리자 권한이 없습니다."); location.href="/";</script>');
//    16     }
//    17 }

//   ---

//   5. 라우터(URL)에 권한 적용하기
//   위에서 만든 함수들을 페이지 경로 중간에 넣어주기만 하면 됩니다.

//     1 // 메인 페이지 (누구나)
//     2 app.get('/', (req, res) => {
//     3     res.send(`<h1>메인 페이지</h1><p>접속자: ${req.session.user ? req.session.user.name : '비회원'}</p>`);
//     4 });
//     5
//     6 // 마이페이지 (로그인한 사람만: checkLogin 추가)
//     7 app.get('/mypage', checkLogin, (req, res) => {
//     8     res.send(`<h1>마이페이지</h1><p>당신의 아이디: ${req.session.user.id}</p>`);
//     9 });
//    10
//    11 // 관리자 전용 페이지 (관리자만: checkAdmin 추가)
//    12 app.get('/admin', checkAdmin, (req, res) => {
//    13     res.send('<h1>관리자 페이지입니다. 회원 목록을 관리할 수 있습니다.</h1>');
//    14 });
//    15
//    16 // 로그아웃
//    17 app.get('/logout', (req, res) => {
//    18     req.session.destroy(); // 세션 삭제
//    19     res.send('<script>alert("로그아웃 되었습니다."); location.href="/";</script>');
//    20 });

//   요점 정리
//    1. 세션(`req.session`): 로그인 성공 시 사용자 정보를 여기에 담아두면, 다른 페이지에서도 req.session.user가 있는지 확인하여 로그인
//       여부를 알 수 있습니다.
//    2. 권한 구분: DB의 USER_ROLE 컬럼에 'ADMIN', 'USER' 같은 값을 넣어두고, 로그인 시 세션에 같이 저장한 뒤 페이지 접속 전에 이 값을
//       체크하면 됩니다.
//    3. 단순 비교: WHERE USER_ID = :id AND PASSWORD = :pw 쿼리 하나면 로그인 로직은 끝납니다. (공부용으로는 가장 직관적입니다!)


    1 -- 1. ACCOUNTS 테이블 (계정)
    2 CREATE TABLE ACCOUNTS (
    3     USER_NO NUMBER PRIMARY KEY,        -- 시퀀스로 들어갈 고유 번호 (PK)
    4     USER_ID VARCHAR2(50) NOT NULL,     -- 로그인 아이디
    5     PASSWORD VARCHAR2(100) NOT NULL,
    6     ROLE VARCHAR2(20) DEFAULT 'USER',
    7
    8     -- [핵심] 아이디 중복을 막기 위해 UNIQUE 제약조건 추가
    9     CONSTRAINT UQ_USER_ID UNIQUE (USER_ID)
   10 );
   11
   12 -- 시퀀스 생성 (이미 만드셨겠지만 예시로)
   13 CREATE SEQUENCE SEQ_USER_NO START WITH 1 INCREMENT BY 1;
   14
   15
   16 -- 2. MEMBERS 테이블 (회원 정보)
   17 -- 여기서는 USER_ID가 아니라, 불변하는 USER_NO를 연결고리로 씁니다!
   18 CREATE TABLE MEMBERS (
   19     INFO_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
   20     USER_NO NUMBER,                    -- ACCOUNTS의 USER_NO를 받아옴
   21     USER_NAME VARCHAR2(50),
   22     EMAIL VARCHAR2(100),
   23
   24     -- [관계 연결] 외래키가 USER_NO를 가리킴
   25     CONSTRAINT FK_USER_NO FOREIGN KEY (USER_NO)
   26     REFERENCES ACCOUNTS(USER_NO)
   27     ON DELETE CASCADE
   28 );

  
    1 app.post('/register', async (req, res) => {
    2     const { id, password, name, email } = req.body;
    3     let connection;
    4
    5     try {
    6         connection = await oracledb.getConnection(dbConfig);
    7
    8         // [1단계] 시퀀스에서 번호를 먼저 하나 뽑아옵니다.
    9         // DUAL은 오라클에서 테스트용으로 쓰는 가짜 테이블입니다.
   10         const seqResult = await connection.execute(
   11             `SELECT SEQ_USER_NO.NEXTVAL AS NEXT_NO FROM DUAL`,
   12             [], // 바인딩 변수 없음
   13             { outFormat: oracledb.OUT_FORMAT_OBJECT } // 결과를 객체로 받기
   14         );
   15
   16         // 미리 뽑은 번호를 변수에 저장 (예: 101번)
   17         const myUserNo = seqResult.rows[0].NEXT_NO;
   18         console.log("확보한 회원 번호:", myUserNo);
   19
   20
   21         // [2단계] 미리 뽑은 번호(myUserNo)를 사용해서 계정 저장
   22         const sqlAccount = `INSERT INTO ACCOUNTS (USER_NO, USER_ID, PASSWORD, ROLE)
   23                             VALUES (:no, :id, :pw, 'USER')`;
   24
   25         await connection.execute(sqlAccount, {
   26             no: myUserNo, // 101번을 넣음
   27             id: id,
   28             pw: password
   29         }, { autoCommit: false }); // 아직 커밋 안 함
   30
   31
   32         // [3단계] 똑같은 번호(myUserNo)를 사용해서 회원정보 저장
   33         const sqlMember = `INSERT INTO MEMBERS (USER_NO, USER_NAME, EMAIL)
   34                            VALUES (:no, :name, :email)`;
   35
   36         await connection.execute(sqlMember, {
   37             no: myUserNo, // 여기도 101번을 넣음 (연결됨!)
   38             name: name,
   39             email: email
   40         }, { autoCommit: false });
   41
   42
   43         // [4단계] 둘 다 성공했으면 저장 확정
   44         await connection.commit();
   45         res.send('<script>alert("가입 성공"); location.href="/login";</script>');
   46
   47     } catch (err) {
   48         if (connection) await connection.rollback();
   49
   50         if (err.message.includes('ORA-00001')) {
   51              res.send('<script>alert("이미 존재하는 아이디입니다."); history.back();</script>');
   52         } else {
   53              console.error(err);
   54              res.send('<script>alert("오류 발생"); history.back();</script>');
   55         }
   56     } finally {
   57         if (connection) await connection.close();
   58     }
   59 });

  이 방식의 장점
   1. 쉬운 문법: SELECT해서 값을 가져오고, 그 값을 INSERT에 넣는 것은 우리가 계속 해오던 방식이라 이해하기 쉽습니다.
   2. 데이터 무결성 유지: 시퀀스(NEXTVAL)를 사용했기 때문에 사용자가 동시에 가입해도 번호가 겹치지 않습니다.

  이제 모르는 문법 없이, 아는 내용만으로 관계형 데이터베이스를 다룰 수 있습니다

    그리고 있다면, 게시글 상세 보기와 댓글 기능도 SPA 방식으로 하나의 페이지에서 처리하는 것을 추천합니다.

  이유와 구현 방법을 정리해 드릴게요.

  1. 왜 SPA 방식을 추천하나요? (같은 페이지 유지)

   * 일관성: 이미 글쓰기와 목록 보기를 SPA로 만들었는데, 상세 보기만 페이지가 넘어가면 사용자 경험(UX)이 끊기는 느낌이 듭니다.
   * 속도: 페이지 전체를 새로고침 하지 않고, 필요한 텍스트 데이터(본문, 댓글)만 서버에서 가져오기 때문에 훨씬 빠릅니다.
   * 상태 유지: 사용자가 스크롤을 내려서 50번째 글을 눌렀을 때, 새 페이지로 갔다가 '뒤로 가기'를 하면 스크롤이 맨 위로 초기화되는 경우가
     많습니다. SPA는 목록 영역을 잠시 숨기는 것이라 스크롤 위치를 유지하기 좋습니다.

  ---

  2. 구현 시나리오 (논리적 흐름)

  화면에는 크게 두 개의 거대한 div가 있다고 생각하면 됩니다.

   1. 목록 영역 (`#post-list-section`): 현재 보고 있는 화면
   2. 상세 보기 영역 (`#post-detail-section`): 평소에는 display: none

  사용자가 글 제목을 클릭하면 일어나는 일:
   1. 목록 영역을 숨김 (display: none)
   2. 상세 보기 영역을 보여줌 (display: block)
   3. 자바스크립트로 서버에 데이터를 요청 (fetch('/post/detail?id=글번호'))
   4. 받아온 데이터(제목, 내용, 조회수, 댓글 등)를 상세 보기 영역의 HTML에 채워 넣음.
   5. [목록으로] 버튼을 누르면 반대로 (상세 숨김 -> 목록 보여줌) 작동.

  ---

  3. 조회수 증가 처리는 어떻게 하나요?

  SPA 방식에서는 링크를 타고 이동하는 게 아니라서, 데이터를 요청할 때 조회수를 올려야 합니다.

  서버(Node.js) 쪽 로직:
  /post/detail API가 호출되면 DB에서 두 가지 일을 순서대로 해야 합니다.
   1. Update: 해당 글 번호의 VIEWS(조회수) 컬럼을 +1 증가시킴.
   2. Select: 증가된 조회수를 포함하여 글 내용을 조회해서 클라이언트에게 돌려줌.

  ---

  4. 코드 예시 (Node.js + Vanilla JS)

  A. HTML 구조

    1 <!-- 1. 글 목록 영역 -->
    2 <div id="list-section">
    3     <h1>게시판 목록</h1>
    4     <button id="write-btn">글쓰기</button>
    5     <div id="post-list">
    6         <!-- 자바스크립트로 <li><a href="#" onclick="loadPost(1)">제목</a></li> 형식으로 그려짐 -->
    7     </div>
    8 </div>
    9
   10 <!-- 2. 글 상세 보기 영역 (처음엔 숨김) -->
   11 <div id="detail-section" style="display: none;">
   12     <button onclick="goBackToList()">목록으로 돌아가기</button>
   13     <h2 id="detail-title"></h2>
   14     <p>조회수: <span id="detail-views"></span></p>
   15     <div id="detail-content"></div>
   16
   17     <hr>
   18     <h3>댓글</h3>
   19     <div id="comment-list"></div>
   20     <!-- 댓글 입력 폼 추가 가능 -->
   21 </div>

  B. 자바스크립트 (클라이언트)

    1 // 게시글 제목 클릭 시 실행되는 함수
    2 async function loadPost(postId) {
    3     try {
    4         // 1. 서버에 상세 정보 요청
    5         const response = await fetch(`/api/post/${postId}`);
    6         const data = await response.json(); // { title: "...", content: "...", views: 10, comments: [] }
    7
    8         // 2. 받아온 데이터로 화면 채우기
    9         document.getElementById('detail-title').innerText = data.title;
   10         document.getElementById('detail-content').innerText = data.content;
   11         document.getElementById('detail-views').innerText = data.views;
   12
   13         // 3. 댓글 그리기 (반복문)
   14         const commentList = document.getElementById('comment-list');
   15         commentList.innerHTML = ''; // 초기화
   16         data.comments.forEach(comment => {
   17             commentList.insertAdjacentHTML('beforeend', `<p>${comment.writer}: ${comment.text}</p>`);
   18         });
   19
   20         // 4. 화면 전환 (목록 숨기기, 상세 보이기)
   21         document.getElementById('list-section').style.display = 'none';
   22         document.getElementById('detail-section').style.display = 'block';
   23
   24     } catch (error) {
   25         console.error("글 불러오기 실패:", error);
   26         alert("글을 불러올 수 없습니다.");
   27     }
   28 }
   29
   30 // 목록으로 돌아가기
   31 function goBackToList() {
   32     document.getElementById('detail-section').style.display = 'none';
   33     document.getElementById('list-section').style.display = 'block';
   34 }

  C. 서버 (Node.js + Express + OracleDB)

    1 app.get('/api/post/:id', async (req, res) => {
    2     const postId = req.params.id;
    3     let connection;
    4
    5     try {
    6         connection = await oracledb.getConnection(dbConfig);
    7
    8         // [중요] 1. 조회수 증가 (트랜잭션 시작)
    9         await connection.execute(
   10             `UPDATE BOARDS SET VIEWS = VIEWS + 1 WHERE ID = :id`,
   11             [postId],
   12             { autoCommit: true } // 조회수 증가는 즉시 반영
   13         );
   14
   15         // 2. 글 내용 가져오기
   16         const postResult = await connection.execute(
   17             `SELECT TITLE, CONTENT, VIEWS, WRITER FROM BOARDS WHERE ID = :id`,
   18             [postId],
   19             { outFormat: oracledb.OUT_FORMAT_OBJECT }
   20         );
   21
   22         // 3. 댓글 가져오기 (테이블이 따로 있다고 가정)
   23         const commentResult = await connection.execute(
   24             `SELECT WRITER, TEXT FROM COMMENTS WHERE BOARD_ID = :id ORDER BY REGDATE ASC`,
   25             [postId],
   26             { outFormat: oracledb.OUT_FORMAT_OBJECT }
   27         );
   28
   29         // 4. 데이터 합쳐서 응답
   30         if (postResult.rows.length > 0) {
   31             const post = postResult.rows[0];
   32             res.json({
   33                 title: post.TITLE,
   34                 content: post.CONTENT,
   35                 views: post.VIEWS, // 증가된 조회수
   36                 writer: post.WRITER,
   37                 comments: commentResult.rows // 댓글 배열
   38             });
   39         } else {
   40             res.status(404).send("글이 없습니다.");
   41         }
   42
   43     } catch (err) {
   44         console.error(err);
   45         res.status(500).send("서버 오류");
   46     } finally {
   47         if (connection) await connection.close();
   48     }
   49 });

  요약 및 팁
   1. SPA 방식 유지 추천: 현재 하시는 방식과 아주 잘 어울립니다.
   2. 화면 전환: display: none/block으로 두 영역을 스위칭하세요.
   3. 조회수: 서버에서 UPDATE 쿼리를 먼저 날리고 SELECT를 해서 데이터를 보내주면 됩니다.
   4. 댓글: 글 상세 정보를 가져올 때 댓글 테이블도 SELECT 해서 한 번에 JSON으로 묶어서 보내주면 네트워크 요청 횟수를 줄일 수 있어
      효율적입니다.

> 그런데 글 목록이 아까 말한대로 fetch를 통해서 동적으로 그려지는 목록인데 그 목록을 클릭하면 그 목록에 맞는 글번호 값을 가져오는 건
  어떻게 해야하는거지?

✦ 아주 좋은 질문입니다! 동적으로 생성되는 HTML 요소(<li>나 <tr> 등)에 데이터를 심어두고, 클릭했을 때 꺼내는 방법이 필요하죠.

  이때 가장 많이 사용하고, 표준적인 방법은 `data-` 속성(dataset)을 사용하는 것입니다.

  1. 목록 그릴 때: 글 번호 심기 (data-id)

  fetch로 받아온 글 목록을 insertAdjacentHTML로 그릴 때, HTML 태그 안에 data-id="${post.id}" 같은 속성을 추가합니다. 이렇게 하면 화면엔
  안 보이지만 브라우저는 이 태그가 몇 번 글인지 알게 됩니다.

  예시 코드 (클라이언트 JS):

    1 // 서버에서 받아온 posts 배열을 반복문으로 돌릴 때
    2 posts.forEach(post => {
    3     // 1. onclick에 함수를 바로 넣는 방법 (가장 쉬움)
    4     // "loadPost(10)" 처럼 함수 호출문 자체가 문자열로 들어감
    5     const html = `
    6         <div class="post-item" onclick="loadPost(${post.ID})">
    7             <h3>${post.TITLE}</h3>
    8             <span>작성자: ${post.WRITER}</span>
    9         </div>
   10     `;
   11
   12     // 또는
   13
   14     // 2. data-id 속성을 활용하는 방법 (이벤트 위임 방식, 더 세련된 방법)
   15     const html2 = `
   16         <div class="post-item" data-id="${post.ID}">
   17             <h3>${post.TITLE}</h3>
   18             <span>작성자: ${post.WRITER}</span>
   19         </div>
   20     `;
   21
   22     document.getElementById('post-list').insertAdjacentHTML('beforeend', html);
   23 });

  ---

  2. 클릭했을 때: 글 번호 꺼내기

  방법 A: onclick에 함수 직접 연결 (쉬움, 초보자 추천)
  위의 1번 방식처럼 HTML을 만들었다면 별다른 처리 없이 함수가 실행됩니다.

   1 // 이 함수는 전역 스코프에 있어야 합니다.
   2 function loadPost(id) {
   3     console.log("클릭한 글 번호:", id); // 10, 11, 12 ...
   4
   5     // 여기서 fetch 요청 보내면 됨
   6     fetch(`/api/post/${id}`).then(...)
   7 }
   * 장점: 직관적이고 구현이 아주 쉽습니다.
   * 단점: HTML 문자열 안에 자바스크립트 함수 호출이 섞여 있어서 코드가 조금 지저분해 보일 수 있습니다.

  방법 B: 이벤트 위임 (Event Delegation) (권장, 성능 좋음)
  동적으로 생성되는 요소가 많을 때, 부모 요소(목록 컨테이너)에 이벤트를 딱 하나만 걸어서 처리하는 방식입니다.

    1 // 목록을 감싸는 부모 요소 (#post-list)
    2 const postListContainer = document.getElementById('post-list');
    3
    4 // 부모에게 클릭 이벤트를 건다 (딱 한 번만 실행됨)
    5 postListContainer.addEventListener('click', function(event) {
    6
    7     // 1. 클릭된 요소가 .post-item 이거나 그 내부 요소인지 확인
    8     // closest('.post-item'): 클릭한 곳에서 가장 가까운 조상 .post-item을 찾음
    9     const clickedItem = event.target.closest('.post-item');
   10
   11     // 2. .post-item을 클릭한 게 맞다면 (빈 공간 클릭 방지)
   12     if (clickedItem) {
   13         // 3. 심어둔 data-id 값을 꺼냄
   14         const postId = clickedItem.dataset.id; // data-id="..." 값을 가져옴
   15         console.log("꺼낸 글 번호:", postId);
   16
   17         // 상세 보기 함수 호출
   18         loadPost(postId);
   19     }
   20 });
   * 장점: 리스트 아이템이 1000개가 되어도 이벤트 리스너는 딱 1개라 메모리를 적게 씁니다. HTML과 JS 로직이 깔끔하게 분리됩니다.
   * 단점: closest나 dataset 개념을 알아야 해서 처음에 조금 낯설 수 있습니다.

  ---

  결론: 어느 것을 쓸까?

   * 가장 빠르게 구현하고 싶다면: 방법 A (`onclick="loadPost(${post.ID})"`)를 쓰세요. 지금 단계에서 전혀 문제 없습니다.
   * 나중에 수정하기 좋고 깔끔하게 만들고 싶다면: 방법 B (이벤트 위임 + `data-id`)를 연습해보세요.

  방법 A 적용 예시 (최종):

    1 // fetch로 받아온 데이터(posts)로 목록 그리기
    2 posts.forEach(item => {
    3     const tempHtml = `
    4         <tr onclick="viewDetail(${item.ID})" style="cursor: pointer;">
    5             <td>${item.ID}</td>
    6             <td>${item.TITLE}</td>
    7             <td>${item.WRITER}</td>
    8             <td>${item.VIEWS}</td>
    9         </tr>
   10     `;
   11     listContainer.insertAdjacentHTML('beforeend', tempHtml);
   12 });
   13
   14 // 상세 보기 함수
   15 function viewDetail(id) {
   16     // 여기서 서버로 id를 보내서 상세 내용을 가져옴
   17     fetch(`/api/board/detail?id=${id}`)
   18     // ... 이후 로직
   19 }

  이렇게 하면 클릭하는 순간 해당 줄의 ID 값이 viewDetail 함수의 인자로 쏙 들어갑니다

> closest를 안배웠어. 지금껏 목록삭제는 parentelement를 찾아서 지우는 걸로 공부를 했었거든.

✦ parentElement를 활용해서 목록을 삭제해오셨다면, 그와 아주 유사한 방식으로 글 번호를 가져올 수 있습니다!

  가장 직관적인 방법 두 가지를 알려드릴게요.

  방법 1: onclick 함수에 번호를 직접 전달하기 (가장 추천)

  목록을 그리실 때, 삭제 버튼을 만드셨던 것처럼 함수 인자에 글 번호를 직접 넣어버리는 방식입니다. 이 방식은 parentElement를 찾을 필요조차
  없어서 매우 간단합니다.

    1 // 목록을 그리는 부분 (fetch 이후)
    2 data.forEach(item => {
    3     const html = `
    4         <tr onclick="showDetail(${item.POST_ID})" style="cursor:pointer">
    5             <td>${item.POST_ID}</td>
    6             <td>${item.TITLE}</td>
    7             <td>${item.WRITER}</td>
    8         </tr>
    9     `;
   10     listTable.insertAdjacentHTML('beforeend', html);
   11 });
   12
   13 // 상세 보기를 처리하는 함수
   14 function showDetail(id) {
   15     console.log("클릭한 글 번호:", id);
   16     // 이제 이 id를 가지고 상세 내용을 가져오는 fetch를 보내면 됩니다.
   17     // 예: fetch('/api/post/detail?id=' + id)
   18 }

  ---

  방법 2: parentElement와 id 속성 활용하기

  현재 익숙하신 parentElement 방식을 사용하고 싶으시다면, 줄(`<tr>`) 자체에 ID를 부여하고 클릭했을 때 그 ID를 읽어오는 방식을 쓰면
  됩니다.

    1 // 1. 목록을 그릴 때 tr에 id를 심습니다.
    2 data.forEach(item => {
    3     const html = `
    4         <tr id="row-${item.POST_ID}" onclick="getIdAndShow(this)">
    5             <td>${item.POST_ID}</td>
    6             <td>${item.TITLE}</td>
    7             <td>${item.WRITER}</td>
    8         </tr>
    9     `;
   10     listTable.insertAdjacentHTML('beforeend', html);
   11 });
   12
   13 // 2. 클릭 시 실행되는 함수
   14 function getIdAndShow(element) {
   15     // element는 클릭된 <tr> 태그 자체입니다. (this로 넘겼으니까요)
   16     // "row-123" 형태의 문자열에서 "row-"를 지우고 숫자만 가져옵니다.
   17     const fullId = element.id;
   18     const postId = fullId.split('-')[1]; // ['row', '123'] 중 두 번째 값
   19
   20     console.log("찾은 글 번호:", postId);
   21     loadDetail(postId); // 상세 보기 로직 실행
   22 }

  만약 <tr>이 아니라 그 안의 특정 버튼을 눌렀을 때 작동하게 하고 싶다면, 평소 삭제 기능을 만드셨을 때처럼 하시면 됩니다.

   1 // 버튼 클릭 시 작동하는 예시
   2 function handleDetailBtn(btn) {
   3     // 버튼의 부모인 td, 그 부모인 tr로 올라감
   4     const row = btn.parentElement.parentElement;
   5     const postId = row.id; // tr에 심어둔 id값 읽기
   6     console.log("글 번호:", postId);
   7 }